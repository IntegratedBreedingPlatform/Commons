
package org.generationcp.commons.service.impl;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.generationcp.commons.breedingview.parsing.SummaryStatsCSV;
import org.generationcp.commons.exceptions.BreedingViewImportException;
import org.generationcp.commons.exceptions.BreedingViewInvalidFormatException;
import org.generationcp.commons.service.BreedingViewImportService;
import org.generationcp.commons.spring.util.ContextUtil;
import org.generationcp.middleware.domain.dms.DMSVariableType;
import org.generationcp.middleware.domain.dms.DataSet;
import org.generationcp.middleware.domain.dms.DataSetType;
import org.generationcp.middleware.domain.dms.DatasetReference;
import org.generationcp.middleware.domain.dms.DatasetValues;
import org.generationcp.middleware.domain.dms.ExperimentType;
import org.generationcp.middleware.domain.dms.ExperimentValues;
import org.generationcp.middleware.domain.dms.PhenotypicType;
import org.generationcp.middleware.domain.dms.StandardVariable;
import org.generationcp.middleware.domain.dms.Stocks;
import org.generationcp.middleware.domain.dms.TrialEnvironment;
import org.generationcp.middleware.domain.dms.TrialEnvironments;
import org.generationcp.middleware.domain.dms.Variable;
import org.generationcp.middleware.domain.dms.VariableList;
import org.generationcp.middleware.domain.dms.VariableTypeList;
import org.generationcp.middleware.domain.oms.CvId;
import org.generationcp.middleware.domain.oms.Term;
import org.generationcp.middleware.domain.oms.TermId;
import org.generationcp.middleware.domain.ontology.Method;
import org.generationcp.middleware.domain.ontology.VariableType;
import org.generationcp.middleware.manager.api.OntologyDataManager;
import org.generationcp.middleware.manager.api.StudyDataManager;
import org.generationcp.middleware.manager.ontology.OntologyDaoFactory;
import org.generationcp.middleware.manager.ontology.api.OntologyMethodDataManager;
import org.generationcp.middleware.manager.ontology.api.OntologyVariableDataManager;
import org.generationcp.middleware.manager.ontology.daoElements.OntologyVariableInfo;
import org.generationcp.middleware.operation.builder.StandardVariableBuilder;
import org.generationcp.middleware.operation.transformer.etl.StandardVariableTransformer;
import org.generationcp.middleware.pojos.dms.DmsProject;
import org.generationcp.middleware.pojos.dms.PhenotypeOutlier;
import org.generationcp.middleware.pojos.oms.CVTerm;
import org.generationcp.middleware.util.DatasetUtil;
import org.springframework.beans.factory.annotation.Autowired;

import com.rits.cloning.Cloner;

import au.com.bytecode.opencsv.CSVReader;

public class BreedingViewImportServiceImpl implements BreedingViewImportService {

	public static final String UNIT_ERRORS_SUFFIX = "_UnitErrors";
	public static final String MEANS_SUFFIX = "_Means";
	private static final String REGEX_VALID_BREEDING_VIEW_CHARACTERS = "[^a-zA-Z0-9-_%']+";
	private static final String LS_MEAN = "LS MEAN";

	@Autowired
	private StudyDataManager studyDataManager;

	@Autowired
	private OntologyVariableDataManager ontologyVariableDataManager;

	@Autowired
	private OntologyDataManager ontologyDataManager;

	@Autowired
	private OntologyDaoFactory ontologyDaoFactory;

	@Autowired
	private Cloner cloner;

	@Autowired
	private OntologyMethodDataManager methodDataManager;

	@Autowired
	private StandardVariableTransformer standardVariableTransformer;

	@Autowired
	private ContextUtil contextUtil;

	private Map<String, String> localNameToAliasMap = null;

	public BreedingViewImportServiceImpl() {

	}

	public BreedingViewImportServiceImpl(final StudyDataManager studyDataManager,
			final OntologyVariableDataManager ontologyVariableDataManager, final OntologyMethodDataManager methodDataManager,
			final OntologyDaoFactory ontologyDaoFactory, final StandardVariableTransformer standardVariableTransformer) {
		this.studyDataManager = studyDataManager;
		this.ontologyVariableDataManager = ontologyVariableDataManager;
		this.methodDataManager = methodDataManager;
		this.ontologyDaoFactory = ontologyDaoFactory;
		this.standardVariableTransformer = standardVariableTransformer;
	}

	/**
	 * This method is called when importing means data that is parsed from an output file generated by Breeding View
	 */
	@Override
	public void importMeansData(final File file, final int studyId) throws BreedingViewImportException {

		boolean meansDataSetExists = false;
		final CVTerm lsMean =
				this.ontologyDaoFactory.getCvTermDao().getByNameAndCvId(BreedingViewImportServiceImpl.LS_MEAN, CvId.METHODS.getId());

		try {

			final DmsProject study = this.studyDataManager.getProject(studyId);
			final DataSet plotDataSet = this.getPlotDataSet(studyId);

			// get the sanitized names to plot dataset variable names as means dataset will be based on this
			final Map<String, String> nameToAliasMap = this.generateNameToAliasMap(studyId, plotDataSet);

			// Get the traits and means from the csv output file generated by Breeding View
			final MeansCSV meansCSV = new MeansCSV(file, nameToAliasMap);
			final Map<String, ArrayList<String>> traitsAndMeans = meansCSV.csvToMap();
			final boolean hasDuplicateColumnsInFile = meansCSV.isHasDuplicateColumns();

			if (!traitsAndMeans.isEmpty()) {

				final String[] csvHeader = traitsAndMeans.keySet().toArray(new String[0]);

				DataSet meansDataSet = this.getMeansDataSet(studyId);
				final DataSet trialDataSet = this.getTrialDataSet(studyId);

				final String programUUID = study.getProgramUUID();
				// Check if means is existing. If yes, only append the variable types to existing means
				// Else, create the means dataset with the means variable types
				if (meansDataSet != null) {
					meansDataSet = this.appendVariableTypesToExistingMeans(csvHeader, plotDataSet, meansDataSet, programUUID, lsMean,
							hasDuplicateColumnsInFile);
					meansDataSetExists = true;
				} else {
					meansDataSet = this.createMeansDataset(studyId, study.getName() + "-MEANS", csvHeader, plotDataSet, programUUID, lsMean,
							hasDuplicateColumnsInFile);
				}
				// create or append the experiments to the means dataset
				this.createOrAppendMeansExperiments(meansDataSet, traitsAndMeans, meansDataSetExists, plotDataSet.getId(),
						trialDataSet.getId());

			}
		} catch (final Exception e) {
			throw new BreedingViewImportException(e.getMessage(), e);
		}
	}

	/**
	 * This method creates or appends the experiments to the means dataset based on the map of traits and means from the output file and the
	 * existing means dataset
	 *
	 * @param meansDataSet
	 * @param traitsAndMeans
	 * @param meansDataSetExists
	 * @param plotDatasetId
	 * @param trialDatasetId
	 */
	private void createOrAppendMeansExperiments(final DataSet meansDataSet, final Map<String, ArrayList<String>> traitsAndMeans,
			final boolean meansDataSetExists, final int plotDatasetId, final int trialDatasetId) {
		final List<ExperimentValues> experimentValuesList = new ArrayList<>();
		final String[] csvHeader = traitsAndMeans.keySet().toArray(new String[0]);
		final String envHeader = csvHeader[0];
		final String entryNoHeader = csvHeader[1];
		final Map<String, Integer> envNameToNdGeolocationIdMap = this.getEnvNameToNdGeolocationIdMap(envHeader, trialDatasetId);
		final Map<String, Integer> entroNyToStockIdMap = this.getEntryNoToStockIdMap(entryNoHeader, plotDatasetId);

		// iterate all environments in the map of traits and means based on the environment factor name
		final List<String> environments = traitsAndMeans.get(envHeader);
		for (int i = 0; i < environments.size(); i++) {
			// Unfortunately, Breeding View cannot handle double quotes in CSV. Because of that, variables in the CSV file with comma are
			// replaced with semicolon
			// So in comparison, we need to replace semicolon with comma again
			final String envName = environments.get(i).replace(";", ",");
			final Integer ndGeolocationId = envNameToNdGeolocationIdMap.get(envName);
			final String entryNo = traitsAndMeans.get(entryNoHeader).get(i);
			final Integer stockId = entroNyToStockIdMap.get(entryNo);

			// create experiment for the given stock id and nd_geolocation id
			final ExperimentValues experimentRow = new ExperimentValues();
			experimentRow.setGermplasmId(stockId);
			experimentRow.setLocationId(ndGeolocationId);

			final List<Variable> list = new ArrayList<Variable>();

			// Iterate through the Mean Variable names in csv file and retrieve its value for current row to save to experiment
			for (int j = 2; j < csvHeader.length; j++) {
				final String meansVariable = csvHeader[j];
				if (meansDataSetExists && meansDataSet.getVariableTypes().getVariates().findByLocalName(meansVariable) == null) {
					continue;
				}

				final String variableValue = traitsAndMeans.get(meansVariable).get(i).trim();
				if (!variableValue.trim().isEmpty()) {
					final Variable var = new Variable(meansDataSet.getVariableTypes().findByLocalName(meansVariable), variableValue);
					list.add(var);
				}

			}

			final VariableList variableList1 = new VariableList();
			variableList1.setVariables(list);
			experimentRow.setVariableList(variableList1);
			experimentValuesList.add(experimentRow);
		}

		// Save the experiments for mean dataset
		this.studyDataManager.addOrUpdateExperiment(meansDataSet.getId(), ExperimentType.AVERAGE, experimentValuesList,
				this.contextUtil.getProjectInContext().getCropType().getPlotCodePrefix());
	}

	/**
	 * This method returns a map of entry no to stock id based from the plot dataset
	 *
	 * @param entryNoHeader
	 * @param plotDatasetId
	 * @return map of entry no to stock id
	 */
	private Map<String, Integer> getEntryNoToStockIdMap(final String entryNoHeader, final int plotDatasetId) {
		final Stocks stocks = this.studyDataManager.getStocksInDataset(plotDatasetId);
		return stocks.getStockMap(entryNoHeader);
	}

	/**
	 * This method returns a map of environment factor values to nd_geolocation ids based from the trial dataset id and the environment
	 * factor name
	 *
	 * @param envFactor
	 * @param trialDatasetId
	 * @return map of environment factor names to nd_geolocation ids
	 */
	private Map<String, Integer> getEnvNameToNdGeolocationIdMap(final String envFactor, final int trialDatasetId) {
		final Map<String, Integer> envNameToGeolocationIdMap = new HashMap<String, Integer>();
		final TrialEnvironments trialEnvironments = this.studyDataManager.getTrialEnvironmentsInDataset(trialDatasetId);
		for (final TrialEnvironment trialEnv : trialEnvironments.getTrialEnvironments()) {
			envNameToGeolocationIdMap.put(trialEnv.getVariables().findByLocalName(envFactor).getValue(), trialEnv.getId());
		}
		return envNameToGeolocationIdMap;
	}

	/**
	 * Create the mean dataset based on the map of traits and means from the output file and save it to the database
	 *
	 * @param studyId
	 * @param datasetName
	 * @param csvHeader
	 * @param plotDataSet
	 * @param programUUID
	 * @param lSMean
	 * @param errorEstimate
	 * @param hasDuplicateColumnsInFile
	 * @return means Dataset
	 */
	private DataSet createMeansDataset(final int studyId, final String datasetName, final String[] csvHeader, final DataSet plotDataSet,
			final String programUUID, final CVTerm lSMean, final boolean hasDuplicateColumnsInFile) {

		final VariableTypeList meansVariableTypeList = new VariableTypeList();
		final VariableList meansVariableList = new VariableList();
		final DatasetValues datasetValues = new DatasetValues();
		datasetValues.setVariables(meansVariableList);

		// add dataset type variables to means dataset (but not yet save it to the database)

		this.addMeansVariableToLists(this.createMeansVariable(TermId.DATASET_NAME.getId(), datasetName, "Dataset name (local)", datasetName,
				1, programUUID, PhenotypicType.DATASET), meansVariableList, meansVariableTypeList);

		this.addMeansVariableToLists(this.createMeansVariable(TermId.DATASET_TITLE.getId(), "DATASET_TITLE", "Dataset title (local)",
				"My Dataset Description", 2, programUUID, PhenotypicType.DATASET), meansVariableList, meansVariableTypeList);

		this.addMeansVariableToLists(
				this.createMeansVariable(TermId.DATASET_TYPE.getId(), "DATASET_TYPE", "Dataset type (local)",
						String.valueOf(DataSetType.MEANS_DATA.getId()), 3, programUUID, PhenotypicType.DATASET),
				meansVariableList, meansVariableTypeList);

		// add plot dataset variables of type trial environment and germplasm to means dataset (but not yet save it to the database)
		this.createMeansVariablesFromPlotDatasetAndAddToList(plotDataSet, meansVariableTypeList, 4);

		// add analysis (mean) variable based from the import file to the means dataset (but not yet save it to the database)
		this.createMeansVariablesFromImportFileAndAddToList(csvHeader, plotDataSet.getVariableTypes().getVariates(), meansVariableTypeList,
				programUUID, lSMean, hasDuplicateColumnsInFile);

		// save and return the newly-created means dataset
		final DatasetReference datasetReference = this.studyDataManager.addDataSet(studyId, meansVariableTypeList, datasetValues, "");
		return this.studyDataManager.getDataSet(datasetReference.getId());

	}

	/**
	 * Create analysis variable (means) for and add
	 *
	 * @param csvHeader
	 * @param plotVariates
	 * @param meansVariableTypeList
	 * @param programUUID
	 * @param lsMean
	 * @param errorEstimate
	 */
	void createMeansVariablesFromImportFileAndAddToList(final String[] csvHeader, final VariableTypeList plotVariates,
			final VariableTypeList meansVariableTypeList, final String programUUID, final CVTerm lsMean, final boolean hasDuplicateColumnsInFile) {
		final boolean isSummaryVariable = false;
		final int numberOfMeansVariables = meansVariableTypeList.getVariableTypes().size();
		int rank = meansVariableTypeList.getVariableTypes().get(numberOfMeansVariables - 1).getRank() + 1;
		final Set<String> inputDataSetVariateNames = this.getAllNewVariatesToProcess(csvHeader, null, hasDuplicateColumnsInFile);
		final Term lsMeanTerm = new Term(lsMean.getCvTermId(), lsMean.getName(), lsMean.getDefinition());

		for (final String variateName : inputDataSetVariateNames) {
			final DMSVariableType variate = plotVariates.findByLocalName(variateName);
			meansVariableTypeList.add(this.createAnalysisVariable(variate, variateName + BreedingViewImportServiceImpl.MEANS_SUFFIX,
					lsMeanTerm, programUUID, rank++, isSummaryVariable));
		}
	}

	/**
	 * Create plot dataset variables of type trial environment and germplasm and add to means dataset variable type list
	 *
	 * @param plotDataSet
	 * @param meansVariableTypeList
	 * @param lastRank
	 */
	private void createMeansVariablesFromPlotDatasetAndAddToList(final DataSet plotDataSet, final VariableTypeList meansVariableTypeList,
			final int lastRank) {
		int rank = lastRank;
		for (final DMSVariableType factorFromDataSet : plotDataSet.getVariableTypes().getFactors().getVariableTypes()) {
			if (factorFromDataSet.getStandardVariable().getPhenotypicType() == PhenotypicType.TRIAL_ENVIRONMENT
					|| factorFromDataSet.getStandardVariable().getPhenotypicType() == PhenotypicType.GERMPLASM) {
				factorFromDataSet.setRank(++rank);
				meansVariableTypeList.add(factorFromDataSet);
			}
		}
	}

	/**
	 * Add variable to the means variable list and means variable type list
	 *
	 * @param variable
	 * @param meansVariableList
	 * @param meansVariableTypeList
	 */
	private void addMeansVariableToLists(final Variable variable, final VariableList meansVariableList,
			final VariableTypeList meansVariableTypeList) {
		meansVariableList.add(variable);
		meansVariableTypeList.add(variable.getVariableType());
	}

	/**
	 * This method creates the means variable with the correct variable type
	 *
	 * @param ontologyVariableId
	 * @param name
	 * @param definition
	 * @param value
	 * @param rank
	 * @param programUUID
	 * @param phenotypicType
	 * @return means variable in the means dataset
	 */
	private Variable createMeansVariable(final int ontologyVariableId, final String name, final String definition, final String value,
			final int rank, final String programUUID, final PhenotypicType phenotypicType) {
		final Variable variable = this.createVariable(ontologyVariableId, value, rank, programUUID, phenotypicType);
		final VariableType variableType = new StandardVariableBuilder(null).mapPhenotypicTypeToDefaultVariableType(phenotypicType, true);
		this.updateDMSVariableType(variable.getVariableType(), name, definition, variableType);
		return variable;
	}

	/**
	 * This method returns the means dataset of the study from the database
	 *
	 * @param studyId
	 * @return means dataset
	 */
	private DataSet getMeansDataSet(final int studyId) {
		final List<DataSet> ds = this.studyDataManager.getDataSetsByType(studyId, DataSetType.MEANS_DATA);
		if (ds != null && !ds.isEmpty()) {
			// return the 1st one as we're sure that we can only have one means dataset per study
			return ds.get(0);
		}
		return null;
	}

	/**
	 * This method is called when importing means data that is parsed from an output file generated by Breeding View with an additional
	 * parameter localNameToAliasMap containing a map of sanitized variable names to variables names from the plot dataset
	 */
	@Override
	public void importMeansData(final File file, final int studyId, final Map<String, String> localNameToAliasMap)
			throws BreedingViewImportException {
		this.localNameToAliasMap = localNameToAliasMap;
		this.importMeansData(file, studyId);
	}

	/**
	 * This method returns the map of method name to method id from the list of method names in the database. If the method name does not
	 * exist, it is created and returned from the database.
	 *
	 * @param methodNameList
	 * @return
	 */
	private Map<String, Integer> findOrSaveMethodsIfNotExisting(final List<String> methodNameList) {
		final Map<String, Integer> methodNameToIdMap = new HashMap<>();
		for (final String methodName : methodNameList) {
			final Integer methodId = this.findOrSaveMethod(methodName, methodName + "  (system generated method)");
			methodNameToIdMap.put(methodName, methodId);
		}
		return methodNameToIdMap;
	}

	/**
	 * This method finds or save the method from the database based from the method name
	 *
	 * @param methodName
	 * @param methodDefinition
	 * @return method id
	 */
	private Integer findOrSaveMethod(final String methodName, final String methodDefinition) {
		Integer methodId = null;
		final CVTerm cvterm = this.ontologyDaoFactory.getCvTermDao().getByNameAndCvId(methodName, CvId.METHODS.getId());
		if (cvterm == null) {
			methodId = this.saveMethod(methodName, methodDefinition);
		} else {
			methodId = cvterm.getCvTermId();
		}
		return methodId;
	}

	/**
	 * This creates a Method instance, save it and return the newly-created method id
	 *
	 * @param methodName
	 * @param methodDefinition
	 * @return method id
	 */
	private Integer saveMethod(final String methodName, final String methodDefinition) {
		final Method method = new Method();
		method.setName(methodName);
		method.setDefinition(methodDefinition);
		this.methodDataManager.addMethod(method);
		return method.getId();
	}

	/**
	 * This method checks if the ontology variable exists
	 *
	 * @param variableName
	 * @return boolean - true if variable exists, else false
	 */
	private boolean isVariableExisting(final String variableName) {
		final CVTerm cvterm = this.ontologyDaoFactory.getCvTermDao().getByNameAndCvId(variableName, CvId.VARIABLES.getId());
		if (cvterm != null) {
			return true;
		}
		return false;
	}

	/**
	 * This method saves an ontology variable with variable type Analysis and returns the newly-created id
	 *
	 * @param name
	 * @param description
	 * @param methodId
	 * @param propertyId
	 * @param scaleId
	 * @param programUUID
	 * @return ontology variable id
	 */
	private Integer saveAnalysisVariable(final String name, final String description, final int methodId, final int propertyId,
			final int scaleId, final String programUUID, final boolean isSummaryVariable) {
		final OntologyVariableInfo variableInfo = new OntologyVariableInfo();
		variableInfo.setName(name);
		variableInfo.setDescription(description);
		variableInfo.setMethodId(methodId);
		variableInfo.setPropertyId(propertyId);
		variableInfo.setScaleId(scaleId);
		variableInfo.setProgramUuid(programUUID);
		variableInfo.addVariableType(isSummaryVariable ? VariableType.ANALYSIS_SUMMARY : VariableType.ANALYSIS);
		this.ontologyVariableDataManager.addVariable(variableInfo);
		return variableInfo.getId();
	}

	/**
	 * This method is used to import summary statistics generated by Breeding View with an additional parameter localNameToAliasMap
	 * containing a map of sanitized variable names to variables names from the plot dataset
	 */
	@Override
	public void importSummaryStatsData(final File file, final int studyId, final Map<String, String> localNameToAliasMap)
			throws BreedingViewImportException {
		this.localNameToAliasMap = localNameToAliasMap;
		this.importSummaryStatsData(file, studyId);
	}

	/**
	 * This method is used to import summary statistics generated by Breeding View. The Summary Stati
	 */
	@Override
	public void importSummaryStatsData(final File file, final int studyId) throws BreedingViewImportException {

		try {
			final DataSet plotDataset = this.getPlotDataSet(studyId);
			// Get the sanitized names to plot dataset variable names as means dataset will be based on this
			final Map<String, String> nameToAliasMap = this.generateNameToAliasMap(studyId, plotDataset);

			// Get the summary statistics from the csv output file generated by Breeding View
			final SummaryStatsCSV summaryStatsCSV = new SummaryStatsCSV(file, nameToAliasMap);
			final Map<String, Map<String, ArrayList<String>>> summaryStatsData = summaryStatsCSV.getData();

			final DmsProject study = this.studyDataManager.getProject(studyId);
			final String programUUID = study.getProgramUUID();
			final DataSet trialDataSet = this.getTrialDataSet(studyId);

			// Used in getting the new project properties
			final VariableTypeList variableTypeListVariates = plotDataset.getVariableTypes().getVariates();

			// Create the summary statistics variable types
			final VariableTypeList summaryStatsVariableTypeList = this.createSummaryStatsVariableTypes(summaryStatsCSV, trialDataSet,
					variableTypeListVariates, nameToAliasMap, programUUID);

			final Map<String, Integer> envFactorTolocationIdMap =
					this.retrieveAllLocationsOfStudy(summaryStatsData.keySet(), studyId, summaryStatsCSV.getTrialHeader());
			final List<ExperimentValues> summaryStatsExperimentValuesList = this.createSummaryStatsExperimentValuesList(trialDataSet,
					envFactorTolocationIdMap, summaryStatsCSV.getSummaryHeaders(), summaryStatsCSV.getData());

			// Save project properties and experiments
			final DmsProject project = new DmsProject();
			project.setProjectId(trialDataSet.getId());
			this.studyDataManager.saveTrialDatasetSummary(project, summaryStatsVariableTypeList, summaryStatsExperimentValuesList,
					new ArrayList<>(envFactorTolocationIdMap.values()));

		} catch (final Exception e) {
			throw new BreedingViewImportException(e.getMessage(), e);
		}

	}

	/**
	 * Create list ExperimentValues for each summary statistic method, for each trait and environment analyzed with
	 * proper value coming from parsed file BMSSummary.csv 
	 * 
	 * @param trialDataSet
	 * @param envFactorTolocationIdMap
	 * @param summaryStatsList
	 * @param summaryStatsData
	 * @return
	 */
	private List<ExperimentValues> createSummaryStatsExperimentValuesList(final DataSet trialDataSet,
			final Map<String, Integer> envFactorTolocationIdMap, final List<String> summaryStatsList,
			final Map<String, Map<String, ArrayList<String>>> summaryStatsData) {

		final List<ExperimentValues> summaryStatsExperimentValuesList = new ArrayList<ExperimentValues>();
		for (final String envFactorValue : envFactorTolocationIdMap.keySet()) {
			for (final String summaryStatName : summaryStatsList) {
				for (final Entry<String, ArrayList<String>> traitSummaryStat : summaryStatsData.get(envFactorValue).entrySet()) {

					final VariableList variableList = new VariableList();
					variableList.setVariables(new ArrayList<Variable>());
					final ExperimentValues experimentValues = new ExperimentValues();
					experimentValues.setVariableList(variableList);
					experimentValues.setLocationId(envFactorTolocationIdMap.get(envFactorValue));

					final DMSVariableType summaryStatVariableType =
							trialDataSet.findVariableTypeByLocalName(traitSummaryStat.getKey() + "_" + summaryStatName);

					if (summaryStatVariableType != null) {
						final String summaryStatValue = traitSummaryStat.getValue().get(summaryStatsList.indexOf(summaryStatName));
						final Variable var = new Variable(summaryStatVariableType, summaryStatValue);
						experimentValues.getVariableList().getVariables().add(var);
						summaryStatsExperimentValuesList.add(experimentValues);
					}
				}
			}
		}
		return summaryStatsExperimentValuesList;
	}

	private Map<String, Integer> retrieveAllLocationsOfStudy(final Set<String> environments, final int studyId,
			final String envFactorName) {
		final Map<String, Integer> envFactorTolocationIdMap = new LinkedHashMap<>();
		final TrialEnvironments trialEnvironments =
				this.studyDataManager.getTrialEnvironmentsInDataset(this.getTrialDataSet(studyId).getId());
		for (final String env : environments) {
			// Unfortunately, Breeding View cannot handle double quotes in CSV. Because of that, variables in the CSV file with comma are
			// replaced with semicolon
			// So in comparison, we need to replace semicolon with comma again
			String envFactor = env.replace(";", ",");
			TrialEnvironment trialEnv = trialEnvironments.findOnlyOneByLocalName(envFactorName, envFactor);
			if (trialEnv == null) {
				envFactor = env;
				trialEnv = trialEnvironments.findOnlyOneByLocalName(envFactorName, envFactor);
			}
			envFactorTolocationIdMap.put(env, trialEnv.getId());
		}
		return envFactorTolocationIdMap;
	}

	/**
	 * This method creates the summary statistics variable types from the relevant summary statistics columns in the BVSummary.csv output
	 * file.
	 *
	 * @param summaryStatsCSV
	 * @param trialDataSet
	 * @param plotVariates
	 * @param nameToAliasMap
	 * @param programUUID
	 * @return VariableTypeList containing the summary statistics
	 * @throws IOException
	 */
	VariableTypeList createSummaryStatsVariableTypes(final SummaryStatsCSV summaryStatsCSV, final DataSet trialDataSet,
			final VariableTypeList plotVariates, final Map<String, String> nameToAliasMap, final String programUUID) throws IOException {
		final VariableTypeList summaryStatsVariableTypeList = new VariableTypeList();

		final List<String> summaryStatsList = summaryStatsCSV.getSummaryHeaders();
		final Map<String, Integer> summaryStatNameToIdMap = this.findOrSaveMethodsIfNotExisting(summaryStatsList);

		final boolean isSummaryVariable = true;
		final int numberOfTrialDatasetVariables = trialDataSet.getVariableTypes().size();
		int rank = trialDataSet.getVariableTypes().getVariableTypes().get(numberOfTrialDatasetVariables - 1).getRank() + 1;

		// Iterate through relevant summary statistics gathered from the output file of Breeding View
		for (final String summaryStatName : summaryStatsList) {
			for (final DMSVariableType variate : plotVariates.getVariableTypes()) {
				final String trait = variate.getLocalName();
				final String localName = trait + "_" + summaryStatName;
				
				// Only create summary statistic variable if not yet existing in trial dataset
				if (nameToAliasMap.containsValue(trait) && trialDataSet.findVariableTypeByLocalName(localName) == null) {
					final DMSVariableType originalVariableType = plotVariates.findByLocalName(trait);
					// Use the method generated for the summary statistic variable
					final Term summaryStatMethod =
							new Term(summaryStatNameToIdMap.get(summaryStatName), summaryStatName, summaryStatName);
					// Create the summary statistic variable type and add to list
					final DMSVariableType summaryStatVariableType = this.createAnalysisVariable(originalVariableType, localName,
							summaryStatMethod, programUUID, rank++, isSummaryVariable);
					summaryStatVariableType.setVariableType(VariableType.ANALYSIS_SUMMARY);
					summaryStatsVariableTypeList.add(summaryStatVariableType);
					trialDataSet.getVariableTypes().add(summaryStatVariableType);

				}
			}
		}

		return summaryStatsVariableTypeList;
	}

	/**
	 * This method imports the outliers from the outlier output file generated by Breeding View
	 */
	@Override
	public void importOutlierData(final File file, final int studyId) throws BreedingViewImportException {

		try {
			final DataSet plotDataset = this.getPlotDataSet(studyId);
			final Map<String, String> nameToAliasMap = this.generateNameToAliasMap(studyId, plotDataset);
			final OutlierCSV outlierCSV = new OutlierCSV(file, nameToAliasMap);
			final Map<String, Map<String, ArrayList<String>>> outlierData = outlierCSV.getData();
			final Map<String, Integer> ndGeolocationIds = new HashMap<String, Integer>();

			final Map<Integer, Integer> stdVariableIds = new HashMap<Integer, Integer>();
			final VariableTypeList plotVariableTypeList = plotDataset.getVariableTypes();

			Integer i = 0;
			for (final String l : outlierCSV.getHeaderTraits()) {
				final Integer traitId = plotVariableTypeList.findByLocalName(l).getId();
				stdVariableIds.put(i, traitId);
				i++;
			}

			final TrialEnvironments trialEnvironments = this.studyDataManager.getTrialEnvironmentsInDataset(plotDataset.getId());
			for (final TrialEnvironment trialEnv : trialEnvironments.getTrialEnvironments()) {
				ndGeolocationIds.put(trialEnv.getVariables().findByLocalName(outlierCSV.getTrialHeader()).getValue(), trialEnv.getId());
			}

			// iterate all environments from the outlier data
			final Set<String> environments = outlierData.keySet();
			for (final String env : environments) {

				final List<PhenotypeOutlier> outliers = new ArrayList<PhenotypeOutlier>();
				final Integer ndGeolocationId = ndGeolocationIds.get(env);

				// iterate all variables with outliers
				for (final Entry<String, ArrayList<String>> plot : outlierData.get(env).entrySet()) {

					final List<Integer> cvTermIds = new ArrayList<Integer>();
					final Integer plotNo = Integer.valueOf(plot.getKey());
					final Map<Integer, String> plotMap = new HashMap<Integer, String>();

					for (int x = 0; x < plot.getValue().size(); x++) {
						final String traitValue = plot.getValue().get(x);
						if (traitValue.isEmpty()) {
							cvTermIds.add(stdVariableIds.get(x));
							plotMap.put(stdVariableIds.get(x), traitValue);
						}

					}

					// retrieve all phenotype id of variables based on the plot no
					final List<Object[]> list = this.studyDataManager.getPhenotypeIdsByLocationAndPlotNo(plotDataset.getId(),
							ndGeolocationId, plotNo, cvTermIds);
					for (final Object[] object : list) {
						// create PhenotypeOutlier objects and add to list
						final PhenotypeOutlier outlier = new PhenotypeOutlier();
						outlier.setPhenotypeId(Integer.valueOf(object[2].toString()));
						outlier.setValue(plotMap.get(Integer.valueOf(object[1].toString())));
						outliers.add(outlier);
					}

				}

				// save the outliers in the database
				this.studyDataManager.saveOrUpdatePhenotypeOutliers(outliers);
			}
		} catch (final Exception e) {
			throw new BreedingViewImportException(e.getMessage(), e);
		}

	}

	/**
	 * This method imports the outliers from the outlier output file generated by Breeding View with an additional parameter
	 * localNameToAliasMap containing a map of sanitized variable names to variables names from the plot dataset
	 */
	@Override
	public void importOutlierData(final File file, final int studyId, final Map<String, String> localNameToAliasMap)
			throws BreedingViewImportException {
		this.localNameToAliasMap = localNameToAliasMap;
		this.importOutlierData(file, studyId);
	}

	/**
	 * This method returns the plot dataset of the study from the database
	 *
	 * @param studyId
	 * @return plot dataset
	 */
	protected DataSet getPlotDataSet(final int studyId) {
		return DatasetUtil.getPlotDataSet(this.studyDataManager, studyId);
	}

	/**
	 * This method returns the trial dataset of the study from the database
	 *
	 * @param studyId
	 * @return trial dataset
	 */
	protected DataSet getTrialDataSet(final int studyId) {
		return DatasetUtil.getTrialDataSet(this.studyDataManager, studyId);
	}

	/**
	 * Add the mean variables to the existing means and save it to the database
	 *
	 * @param csvHeader - array of headers in 
	 * @param inputDataSet
	 * @param meansDataSet
	 * @param programUUID
	 * @param lsMean
	 * @param errorEstimate
	 * @return means dataset
	 */
	protected DataSet appendVariableTypesToExistingMeans(final String[] csvHeader, final DataSet plotDataSet, final DataSet meansDataSet,
			final String programUUID, final CVTerm lsMean, final boolean hasDuplicateColumnsInFile) {
		final int numberOfMeansVariables = meansDataSet.getVariableTypes().getVariableTypes().size();
		int rank = meansDataSet.getVariableTypes().getVariableTypes().get(numberOfMeansVariables - 1).getRank() + 1;
		final Set<String> inputDataSetVariateNames = this.getAllNewVariatesToProcess(csvHeader,
				meansDataSet.getVariableTypes().getVariates().getVariableTypes(), hasDuplicateColumnsInFile);
		final Term lsMeanTerm = new Term(lsMean.getCvTermId(), lsMean.getName(), lsMean.getDefinition());
		final boolean isSummaryVariable = false;
		for (final String variateName : inputDataSetVariateNames) {
			final DMSVariableType variate = plotDataSet.getVariableTypes().findByLocalName(variateName);
			// add means of the variate to the means dataset
			this.addVariableToDataset(meansDataSet, this.createAnalysisVariable(variate,
					variateName + BreedingViewImportServiceImpl.MEANS_SUFFIX, lsMeanTerm, programUUID, rank++, isSummaryVariable));
		}

		return meansDataSet;
	}

	/**
	 * This saves the variable type under the dataset in the database
	 *
	 * @param dataSet
	 * @param meansVariableType
	 */
	private void addVariableToDataset(final DataSet dataSet, final DMSVariableType meansVariableType) {
		this.studyDataManager.addDataSetVariableType(dataSet.getId(), meansVariableType);
		dataSet.getVariableTypes().add(meansVariableType);
	}

	/***
	 *
	 * This method creates the analysis variable based from the variates in the plot dataset. Basically, the difference between the original
	 * variate and the new means variable is their name and the ontology variable where they are associated, having a different method and
	 * having no specific variable value constraints. This method also creates the ontology variable if it is still not existing.
	 *
	 * @param originalVariableType - the variate where the analysis variable will be based
	 * @param name - the name of the analysis variable
	 * @param method - the method of the analysis variable
	 * @param programUUID - the program where the analysis belongs
	 * @param rank - the rank of the analysis variable from the list
	 * @return DMSVariableType - the new analysis variable
	 */
	protected DMSVariableType createAnalysisVariable(final DMSVariableType originalVariableType, final String name, final Term method,
			final String programUUID, final int rank, final boolean isSummaryVariable) {
		final DMSVariableType analysisVariableType = this.cloner.deepClone(originalVariableType);
		analysisVariableType.setLocalName(name);
		final StandardVariable standardVariable = analysisVariableType.getStandardVariable();
		standardVariable.setMethod(method);

		Integer analysisVariableID = this.ontologyDataManager
				.retrieveDerivedAnalysisVariable(originalVariableType.getStandardVariable().getId(), method.getId());

		if (analysisVariableID == null) {

			String variableName = name;
			if (this.isVariableExisting(variableName)) {
				variableName = variableName + "_1";
			}

			analysisVariableID =
					this.saveAnalysisVariable(variableName, standardVariable.getDescription(), standardVariable.getMethod().getId(),
							standardVariable.getProperty().getId(), standardVariable.getScale().getId(), programUUID, isSummaryVariable);
			this.ontologyDataManager.addCvTermRelationship(originalVariableType.getStandardVariable().getId(), analysisVariableID,
					TermId.HAS_ANALYSIS_VARIABLE.getId());

			standardVariable.setId(analysisVariableID);
			standardVariable.setPhenotypicType(PhenotypicType.VARIATE);

		} else {

			analysisVariableType
					.setStandardVariable(this.createStandardardVariable(analysisVariableID, programUUID, PhenotypicType.VARIATE));
		}

		analysisVariableType.setRank(rank);
		return analysisVariableType;
	}

	/***
	 *
	 * This method processes the headers from the CSV file which are list of means variable names. The variate names are extracted from the
	 * headers and added to the list. Variates with existing means variables are removed from the list to be returned.
	 *
	 * @param csvHeader - the array of headers from the CSV file
	 * @param existingMeansVariables - existing means variables in the means dataset of the study
	 * @return Set<String> - unique list of new variates
	 */
	private Set<String> getAllNewVariatesToProcess(final String[] csvHeader, final List<DMSVariableType> existingMeansVariables,
			final boolean hasDuplicateColumnsInFile) {
		final Set<String> newVariateNames = new LinkedHashSet<>();
		int variatesStartingIndex = 3;
		if (hasDuplicateColumnsInFile) {
			variatesStartingIndex = 2;
		}
		// Exclude the environment, entry # and gid factors which are first column headers
		final List<String> inputDataSetVariateNames =
				new ArrayList<String>(Arrays.asList(Arrays.copyOfRange(csvHeader, variatesStartingIndex, csvHeader.length)));

		for (final String csvHeaderNames : inputDataSetVariateNames) {
			final String variateName = csvHeaderNames.substring(0, csvHeaderNames.lastIndexOf("_"));
			newVariateNames.add(variateName);
		}

		// Only process the new traits that were not part of the previous analysis
		if (existingMeansVariables != null) {
			for (final DMSVariableType var : existingMeansVariables) {
				String variateName = var.getLocalName().trim();
				variateName = variateName.substring(0, variateName.lastIndexOf("_"));
				newVariateNames.remove(variateName);
			}
		}

		return newVariateNames;
	}

	/**
	 * This method returns a standard variable object from the database given the ontology variable field values
	 *
	 * @param termId
	 * @param programUUID
	 * @param phenotypicType
	 * @return StandardVariable instance of the ontology variable
	 */
	protected StandardVariable createStandardardVariable(final int termId, final String programUUID, final PhenotypicType phenotypicType) {
		final org.generationcp.middleware.domain.ontology.Variable ontologyVariable =
				this.ontologyVariableDataManager.getVariable(programUUID, termId, false, false);
		final StandardVariable standardVariable = this.standardVariableTransformer.transformVariable(ontologyVariable);
		standardVariable.setPhenotypicType(phenotypicType);
		return standardVariable;
	}

	/**
	 * This method returns a Variable object given the ontology variable field values
	 *
	 * @param termId
	 * @param value
	 * @param rank
	 * @param programUUID
	 * @param phenotypicType
	 * @return Variable instance
	 */
	protected Variable createVariable(final int termId, final String value, final int rank, final String programUUID,
			final PhenotypicType phenotypicType) {

		final StandardVariable stVar = this.createStandardardVariable(termId, programUUID, phenotypicType);

		final DMSVariableType vtype = new DMSVariableType();
		vtype.setStandardVariable(stVar);
		vtype.setRank(rank);
		vtype.setRole(phenotypicType);
		final Variable var = new Variable();
		var.setValue(value);
		var.setVariableType(vtype);
		return var;
	}

	/**
	 * This method sets the name, description and variable type of the DMSVariableType object
	 *
	 * @param type
	 * @param name
	 * @param description
	 * @param variableType
	 */
	protected void updateDMSVariableType(final DMSVariableType type, final String name, final String description,
			final VariableType variableType) {
		type.setLocalName(name);
		type.setLocalDescription(description);
		type.setVariableType(variableType);
	}

	/**
	 * This method is retrieves the existing plot dataset variables and creates a map of sanitized names to the variable names
	 *
	 * @param studyId
	 * @return Map of sanitized names to local variable names
	 */
	protected Map<String, String> generateNameToAliasMap(final int studyId, final DataSet plotDataset) {

		if (this.localNameToAliasMap != null) {
			return this.localNameToAliasMap;
		} else {
			final List<DMSVariableType> variateList = plotDataset.getVariableTypes().getVariableTypes();

			final Map<String, String> nameAliasMap = new HashMap<>();

			String entryNoName = null;
			for (final Iterator<DMSVariableType> variateListIterator = variateList.iterator(); variateListIterator.hasNext();) {
				final DMSVariableType variable = variateListIterator.next();
				if (variable.getStandardVariable().getId() == TermId.ENTRY_NO.getId()) {
					entryNoName = variable.getLocalName();
				}
				final String nameSanitized =
						variable.getLocalName().replaceAll(BreedingViewImportServiceImpl.REGEX_VALID_BREEDING_VIEW_CHARACTERS, "_");
				nameAliasMap.put(nameSanitized, variable.getLocalName());
			}

			this.mapDupeEntryNoToActualEntryNo(nameAliasMap, entryNoName);
			return nameAliasMap;
		}
	}

	// This will handle the duplicate entry no generated by Breeding View if ENTRY_NO is used a genotypes value
	private void mapDupeEntryNoToActualEntryNo(final Map<String, String> nameAliasMap, final String entryNoName) {
		nameAliasMap.put(entryNoName + "_1", entryNoName);
	}

	/**
	 * This class parses a file and creates a map of variable names to a list of trait and means values
	 *
	 */
	public class MeansCSV {

		private final Map<String, String> nameToAliasMapping;
		private final File file;
		private boolean hasDuplicateColumns;

		public MeansCSV(final File file, final Map<String, String> nameToAliasMapping) {
			this.file = file;
			this.nameToAliasMapping = nameToAliasMapping;
		}

		/**
		 * Parse csv file and return a map of column header names with their corresponding list of values
		 * @return
		 * @throws IOException
		 */
		public Map<String, ArrayList<String>> csvToMap() throws IOException {

			final CSVReader reader = new CSVReader(new FileReader(this.file));
			final Map<String, ArrayList<String>> csvMap = new LinkedHashMap<String, ArrayList<String>>();
			final String[] headers = reader.readNext();
			// track columns to skip - they are skipped because they are duplicates and for Unit Errors variables
			final List<Integer> columnIndexesToSkip = new ArrayList<>();
			int columnIndex = 0;
			for (final String headerCol : headers) {
				// Trim the suffixes from BV output file to extract trait name
				final String aliasLocalName = headerCol.trim().replace(BreedingViewImportServiceImpl.MEANS_SUFFIX, "")
						.replace(BreedingViewImportServiceImpl.UNIT_ERRORS_SUFFIX, "");
				String actualLocalName = null;

				actualLocalName = this.nameToAliasMapping.get(aliasLocalName);
				if (actualLocalName == null) {
					actualLocalName = aliasLocalName;
				}

				final String newHeaderName = headerCol.trim().replace(aliasLocalName, actualLocalName);
				// Mark duplicate columns for skipping when building map
				if (csvMap.containsKey(newHeaderName)) {
					columnIndexesToSkip.add(columnIndex);
					this.hasDuplicateColumns = true;

				// Exclude "Unit Errors" analysis variables from map as we won't be saving them
				} else if (newHeaderName.endsWith(BreedingViewImportServiceImpl.UNIT_ERRORS_SUFFIX)) {
					columnIndexesToSkip.add(columnIndex);
					
				} else {
					csvMap.put(newHeaderName, new ArrayList<String>());
				}
				columnIndex++;

			}
			// Add the cell values to list of values per trait
			final String[] trimHeader = csvMap.keySet().toArray(new String[0]);
			String[] nextLine;
			while ((nextLine = reader.readNext()) != null) {
				int uniqueColumnsIndex = 0;
				for (int i = 0; i < headers.length; i++) {
					if (columnIndexesToSkip.contains(i)) {
						continue;
					}
					csvMap.get(trimHeader[uniqueColumnsIndex]).add(nextLine[i].trim());
					uniqueColumnsIndex++;
				}
			}

			reader.close();

			return csvMap;
		}

		public void validate() throws BreedingViewInvalidFormatException {

			int meansCounter = 0;

			CSVReader reader;
			String[] header = new String[] {};

			try {
				reader = new CSVReader(new FileReader(this.file));
				header = reader.readNext();
				reader.close();
			} catch (final Exception e) {
				throw new BreedingViewInvalidFormatException("A problem occurred while reading the MEANS data file", e);
			}

			for (final String s : header) {
				if (s.contains(BreedingViewImportServiceImpl.MEANS_SUFFIX)) {
					meansCounter++;
				}
			}

			if (meansCounter == 0) {
				throw new BreedingViewInvalidFormatException("Cannot parse the file because the format is invalid for MEANS data.");
			}
		}

		public boolean isHasDuplicateColumns() {
			return this.hasDuplicateColumns;
		}

	}

	/**
	 * This class parses a file and creates a map of variable names to a list of outlier values
	 *
	 */
	public class OutlierCSV {

		private final File file;
		private Map<String, Map<String, ArrayList<String>>> data;
		private final Map<String, String> nameToAliasMapping;
		private String[] header;

		public OutlierCSV(final File file, final Map<String, String> nameToAliasMapping) {
			this.file = file;
			this.nameToAliasMapping = nameToAliasMapping;
		}

		public List<String> getHeader() throws IOException {

			this.data = this.getData();

			return Arrays.asList(this.header);
		}

		public List<String> getHeaderTraits() throws IOException {

			this.data = this.getData();

			final List<String> list = new ArrayList<String>(Arrays.asList(this.header));
			list.remove(0);
			list.remove(0);
			return list;
		}

		public String getTrialHeader() throws IOException {

			return this.getHeader().get(0);
		}

		public Map<String, Map<String, ArrayList<String>>> getData() throws IOException {

			if (this.data != null) {
				return this.data;
			}

			final CSVReader reader = new CSVReader(new FileReader(this.file));
			this.data = new LinkedHashMap<String, Map<String, ArrayList<String>>>();

			final List<String> list = new ArrayList<String>();
			for (final String aliasLocalName : reader.readNext()) {
				String actualLocalName = null;
				actualLocalName = this.nameToAliasMapping.get(aliasLocalName);
				if (actualLocalName == null) {
					actualLocalName = aliasLocalName;
				}
				list.add(actualLocalName);
			}

			this.header = list.toArray(new String[0]);

			String[] nextLine;
			while ((nextLine = reader.readNext()) != null) {
				final String environment = nextLine[0].trim();
				final String trait = nextLine[1].trim();

				if (!this.data.containsKey(environment)) {
					this.data.put(environment, new LinkedHashMap<String, ArrayList<String>>());
				}

				if (!this.data.get(environment).containsKey(trait)) {
					this.data.get(environment).put(trait, new ArrayList<String>());
				}
				for (int i = 2; i < this.header.length; i++) {
					this.data.get(environment).get(trait).add(nextLine[i].trim());
				}

			}

			reader.close();
			return this.data;
		}

		public void validate() throws BreedingViewInvalidFormatException {

			CSVReader reader;
			try {
				reader = new CSVReader(new FileReader(this.file));
				reader.readNext();
				reader.close();
			} catch (final Exception e) {
				throw new BreedingViewInvalidFormatException("A problem occurred while reading the Outlier data file", e);
			}
		}

	}

	protected void setCloner(final Cloner cloner) {
		this.cloner = cloner;
	}

}
