package org.generationcp.commons.parsing;

import org.apache.poi.ss.usermodel.Workbook;
import org.generationcp.commons.parsing.pojo.ImportedDescriptionDetails;
import org.generationcp.commons.parsing.pojo.ImportedFactor;
import org.generationcp.commons.parsing.pojo.ImportedInventoryListWithDescription;
import org.generationcp.commons.parsing.pojo.ImportedVariate;
import org.generationcp.commons.parsing.validation.NonEmptyValidator;
import org.generationcp.commons.parsing.validation.ParseValidationMap;
import org.generationcp.commons.parsing.validation.ValueTypeValidator;
import org.generationcp.middleware.domain.inventory.InventoryDetails;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by cyrus on 4/24/15.
 */
public class GermplasmStockImportParser extends AbstractExcelFileParser<ImportedInventoryListWithDescription> {
	private static final Logger LOG = LoggerFactory.getLogger(GermplasmStockImportParser.class);

	public static final String ALL_LOCATION_VALUES_REQUIRED = "inventory.import.parsing.validation.error.blank.location.value";
	public static final String INVALID_HEADERS = "common.parsing.invalid.headers";
	public static final String NO_REFERENCES_ERROR_DESC = "study.import.inventory.error.no.references";


	protected enum HeaderLabels {
		ENTRY("ENTRY"),
		DESIGNATION("DESIGNATION"),
		GID("GID"),
		CROSS("CROSS"),
		SOURCE("SOURCE"),
		ENTRY_CODE("ENTRY CODE"),
		STOCKID("STOCKID"),
		SEED_QUANTITY("SEED_QUANTITY");

		private String label;

		HeaderLabels(String label) {
			this.label = label;
		}

		public String getLabel() {
			return label;
		}

		public static String[] names() {
			HeaderLabels[] values = values();
			String[] names = new String[values.length];

			for (int i = 0; i < values.length; i++) {
				names[i] = values[i].name();
			}

			return names;
		}
	}

	protected static final int OBSERVATION_SHEET_NO = 1;
	private int currentParseIndex = 0;

	private DescriptionSheetParser<ImportedDescriptionDetails> descriptionSheetParser;

	private Map<String, Integer> observationColumnMap = new HashMap<>();
	private ImportedInventoryListWithDescription importedInventoryListWithDescription;

	@Override
	public ImportedInventoryListWithDescription parseWorkbook(Workbook workbook)
			throws FileParsingException {
		this.workbook = workbook;
		importedInventoryListWithDescription = new ImportedInventoryListWithDescription();
		descriptionSheetParser = new DescriptionSheetParser<>(importedInventoryListWithDescription.getImportedDescriptionDetails());
		descriptionSheetParser.setDoParseConstants(false);

		descriptionSheetParser.parseWorkbook(this.workbook);
		importedInventoryListWithDescription.setFilename(importedInventoryListWithDescription.getImportedDescriptionDetails().getFilename());

		parseObservationSheet();

		return importedInventoryListWithDescription;
	}

	/**
	 * Overide this for the autogenerated seed inventory
	 * @throws FileParsingException
	 */
	protected void parseObservationSheet() throws FileParsingException {
		// validate obs header, this will also fillup the observation column map
		if (isObservationsHeaderInvalid()) {
			throw new FileParsingException("Invalid Observation headers");
		}

		currentParseIndex = 1;

		// setup validation for the stock inventory
		ParseValidationMap parseValidationMap = inventoryValidatorWithRequiredStockId();
		InventoryWithStockIdConverter inventoryWithStockIdConverter = new InventoryWithStockIdConverter(workbook,currentParseIndex,
				OBSERVATION_SHEET_NO,importedInventoryListWithDescription.getImportedDescriptionDetails().sizeOfObservationHeader(),HeaderLabels.names(),observationColumnMap);
		inventoryWithStockIdConverter.setValidationMap(parseValidationMap);

		List<InventoryDetails> detailsList = inventoryWithStockIdConverter.convertWorkbookRowsToObject(
				new WorkbookRowConverter.ContinueTillBlank());

		importedInventoryListWithDescription.setImportedInventoryDetails(detailsList);

	}

	protected ParseValidationMap inventoryValidatorWithRequiredStockId() {
		ParseValidationMap validationMap = new ParseValidationMap();

		// validation for ENTRY column
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.ENTRY.getLabel()), new ValueTypeValidator(Integer.class));
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.ENTRY.getLabel()), new NonEmptyValidator());

		validationMap.addValidation(observationColumnMap.get(HeaderLabels.DESIGNATION.getLabel()), new NonEmptyValidator());

		validationMap.addValidation(observationColumnMap.get(HeaderLabels.GID.getLabel()),
				new ValueTypeValidator(Integer.class));
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.GID.getLabel()), new NonEmptyValidator());

		validationMap.addValidation(observationColumnMap.get(HeaderLabels.CROSS.getLabel()), new NonEmptyValidator());
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.SOURCE.getLabel()), new NonEmptyValidator());
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.STOCKID.getLabel()), new NonEmptyValidator());
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.SEED_QUANTITY.getLabel()), new ValueTypeValidator(Double.class));

		return validationMap;
	}


	protected boolean isObservationsHeaderInvalid() {
		final List<ImportedFactor> importedFactors = new ArrayList<ImportedFactor>() {
			@Override
			public boolean contains(Object o) {
				for (ImportedFactor i : this) {
					if (i.getFactor().equalsIgnoreCase(o.toString())) {
						return true;
					}
				}
				return false;
			}
		};

		importedFactors.addAll(importedInventoryListWithDescription.getImportedDescriptionDetails().getImportedFactors());

		final List<ImportedVariate> importedVariates = new ArrayList<ImportedVariate>() {
			@Override
			public boolean contains(Object o) {
				for (ImportedVariate i : this) {
					if (i.getVariate().equalsIgnoreCase(o.toString())) {
						return true;
					}
				}
				return false;
			}
		};

		importedVariates.addAll(importedInventoryListWithDescription.getImportedDescriptionDetails().getImportedVariates());

		final int headerSize = importedInventoryListWithDescription.getImportedDescriptionDetails().sizeOfObservationHeader();

		for (int i = 0; i < headerSize; i++) {
			// search the current header
			String obsHeader = getCellStringValue(OBSERVATION_SHEET_NO, 0, i);

			boolean inFactors = importedFactors.contains(obsHeader);
			boolean inVariates = importedVariates.contains(obsHeader);

			if (!inFactors && !inVariates) {
				return true;
			} else {
				observationColumnMap.put(obsHeader, i);
			}
		}

		return false;
	}

	public class InventoryWithStockIdConverter extends WorkbookRowConverter<InventoryDetails> {

		private Map<String,Integer> observationColumnMap;

		public InventoryWithStockIdConverter(Workbook workbook, int startingIndex,
				int targetSheetIndex,
				int columnCount, String[] columnLabels,
				Map<String,Integer> observationColumnMap) {
			super(workbook, startingIndex, targetSheetIndex, columnCount, columnLabels);
			this.observationColumnMap = observationColumnMap;
		}

		@Override
		public InventoryDetails convertToObject(Map<Integer, String> rowValues)
				throws FileParsingException {
			// TODO: provide feature for mapping of columns to a different column order
			Integer entryId = Integer
					.parseInt(
							rowValues.get(observationColumnMap.get(HeaderLabels.ENTRY.getLabel())));
			String desig = rowValues.get(
					observationColumnMap.get(HeaderLabels.DESIGNATION.getLabel()));
			Integer gid = Integer.parseInt(rowValues.get(observationColumnMap.get(HeaderLabels.GID.getLabel())));
			String cross = rowValues.get(observationColumnMap.get(HeaderLabels.CROSS.getLabel()));
			String source = rowValues.get(observationColumnMap.get(HeaderLabels.SOURCE.getLabel()));
			String entryCode = rowValues.get(observationColumnMap.get(
					HeaderLabels.ENTRY_CODE.getLabel()));
			String stockId = rowValues.get(observationColumnMap.get(
					HeaderLabels.STOCKID.getLabel()));
			Double seedQuantity = Double.parseDouble(rowValues.get(observationColumnMap.get(
					HeaderLabels.SEED_QUANTITY.getLabel())));

			return new InventoryDetails(entryId,desig,gid,cross,source,entryCode,stockId,seedQuantity);
		}
	}
}
